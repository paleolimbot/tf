
#' Create TensorFlow Tensors
#'
#' @param x An object to convert to a tensor
#' @param .ptype An R vector template (e.g., [double()], [integer()], [logical()],
#'   [raw()], [complex()], or [character()]).
#' @param .tf_ptype A data type identifier, probably generated by [tf_ptype()]
#'   or [tf_ptype_from_label()].
#' @param label One of 'FLOAT', 'DOUBLE', 'INT32', 'UINT8', 'INT16', 'INT8',
#'   'STRING', 'COMPLEX64', 'INT64', 'BOOL', 'UINT16', 'COMPLEX128', 'UINT32',
#'   or 'UINT64'.
#' @param ... Unused
#'
#' @return An object of class 'tf_tensor'
#' @export
#'
#' @examples
#' (t <- as_tf_tensor(matrix(1)))
#' tf_tensor_attributes(t)
#'
as_tf_tensor <- function(x, ...) {
  UseMethod("as_tf_tensor")
}

#' @rdname as_tf_tensor
#' @export
as_tf_tensor.tf_tensor <- function(x, ...) {
  x
}

#' @rdname as_tf_tensor
#' @export
as_tf_tensor.array <- function(x, ..., .tf_ptype = tf_ptype(x)) {
  if (is.character(.tf_ptype)) {
    .tf_ptype = tf_ptype_from_label(.tf_ptype)
  }

  # aperm() takes care of the row-major/column-major difference
  # in the same way that keras does
  x[] <- aperm(x, rev(seq_along(dim(x))))

  .Call("tf_c_tensor_xptr_from_array", x, .tf_ptype)
}

#' @rdname as_tf_tensor
#' @export
tf_tensor_clone <- function(x) {
  .Call("tf_c_tensor_xptr_clone_tensor_xptr", x)
}

#' @rdname as_tf_tensor
#' @export
as.array.tf_tensor <- function(x, ..., .ptype = ptype_from_tf_tensor(x)) {
  stopifnot(tf_tensor_valid(x))
  result <- .Call("tf_c_array_from_tensor_xptr", x, .ptype)
  # aperm() takes care of the row-major/column-major difference
  # in the same way that keras does
  dim(result) <- rev(dim(result))
  aperm(result, rev(seq_along(dim(result))))
}

#' @rdname as_tf_tensor
#' @export
ptype_from_tf_tensor <- function(x) {
  attrs <- tf_tensor_attributes(x)
  switch(
    attrs$data_type_label,
    "FLOAT" =,
    "INT64" =,
    "UINT64" =,
    "UINT32" =,
    "DOUBLE" = double(),
    "BOOL" = logical(),
    "INT8" =,
    "INT16" =,
    "INT32" =,
    "UINT8" =,
    "UINT16" = integer(),
    "COMPLEX64" =,
    "COMPLEX128" = complex(),
    stop(
      sprintf(
        "Can't automatically choose ptype for tf_tensor with data type '%s'",
        attrs$data_type_label
      )
    )
  )
}

#' @rdname as_tf_tensor
#' @export
tf_ptype <- function(x) {
  switch(
    typeof(x),
    "externalptr" = structure(tf_tensor_attributes(x)$data_type, class = "tf_ptype"),
    "double" = tf_ptype_from_label("DOUBLE"),
    "integer" = tf_ptype_from_label("INT32"),
    "logical" = tf_ptype_from_label("BOOL"),
    "complex" = tf_ptype_from_label("COMPLEX128"),
    "character" = tf_ptype_from_label("STRING")
  )
}

#' @rdname as_tf_tensor
#' @export
tf_ptype_from_label <- function(label) {
  if (!is.character(label)) {
    stop("`label` must be a 'character' of length", call. = FALSE)
  }

  enum_r <- c(
    FLOAT = 1L,
    DOUBLE = 2L,
    INT32 = 3L,
    UINT8 = 4L,
    INT16 = 5L,
    INT8 = 6L,
    STRING = 7L,
    COMPLEX64 = 8L,
    INT64 = 9L,
    BOOL = 10L,
    UINT16 = 17L,
    COMPLEX128 = 18L,
    UINT32 = 22L,
    UINT64 = 23L
  )

  int_val <- enum_r[label[1]]
  if (identical(int_val, NA_integer_)) {
    stop(
      sprintf("Can't create a tf_ptype from label '%s'", label[1]),
      call. = FALSE
    )
  }

  int_val
}


#' Inspect Tensors
#'
#' @param x A [tf_tensor][as_tf_tensor]
#'
#' @export
#'
tf_tensor_attributes <- function(x) {
  stopifnot(tf_tensor_valid(x))
  .Call("tf_c_tensor_xptr_attributes", x)
}

#' @rdname tf_tensor_attributes
#' @export
tf_tensor_valid <- function(x) {
  externalptr_valid(x, "tf_tensor")
}

#' @export
format.tf_tensor <- function(x, ...) {
  if (!tf_tensor_valid(x)) {
    return("<tf_tensor NULL>")
  }

  attrs <- tf_tensor_attributes(x)
  sprintf(
    "<tf_tensor<%s>[%s] at %s>",
    attrs$data_type_label,
    paste0(attrs$shape, collapse = ", "),
    externalptr_addr(x)
  )
}

#' @export
print.tf_tensor <- function(x, ...) {
  cat(format(x))
  cat("\n")
  invisible(x)
}
